require("gui/WindowUtils")
require("GameUtils")

local GameCoreHelper = CS.GameCoreHelper

--页面访问控件
local contentPane

local btnBack
local btnRepairAll

local lvItemsList
local ctlResBox
local ctlMatResBox

local curRepairAllCost
local allRepairItems

local playerRole
local gameWorld

local StringFormat = GameCoreHelper.StringFormat

--窗体初始化时
function onInit()
	contentPane = self.contentPane

	playerRole = GameCoreHelper.GetPlayerRole();
	gameWorld = GameCoreHelper.GetCurGameWorld();

	lvItemsList = contentPane:GetChild("party_list").asList;

	--ctlResBox = CreateStandardResBoxByList(contentPane:GetChild("res_list").asList, true);

	local groupRightBar = contentPane:GetChild("g_rightbar").asGroup;
	ctlMatResBox = CreateStandardResBoxByList(contentPane:GetChildInGroup(groupRightBar, "mat_list").asList, false);
	btnRepairAll = contentPane:GetChildInGroup(groupRightBar, "btn_restoreall").asButton

	--绑定按钮事件
	btnBack = contentPane:GetChild("btn_close").asButton;
	btnBack.onClick:Set(onClickBackBtn);

	btnRepairAll.onClick:Add(onClickRepairAll);

	UpdateAllRepairItems();

	if IsMobileMode then
		CreateQuickCloseBg(contentPane, onClickBackBtn)
	end
end

--窗体开始显示并播放显示动画时
function onDoShowAnimation()
	CommonShowWindowAnim(self, onShown)
end

--窗体播放完显示动画时
function onShown()
	--增加计时器事件
	--CS.FairyGUI.Timers.inst:Add(timerTickInterval, 0, onTimerTickUpdate);
end

--窗体开始播放关闭动画时
function onDoHideAnimation()
	CommonHideWindowAnim(self, onHideAnimationDone)
end

function onHideAnimationDone()
	self:HideImmediately();
end

--窗体隐藏时
function onHide()
	--移除计时器事件
	--CS.FairyGUI.Timers.inst:Remove(onTimerTickUpdate);
end

--按下完成按钮时
function onClickBackBtn()
	PlayButtonSound();

	self:Hide();
end

--按下完成按钮时
function onClickRepairAll()
	PlayButtonSound()
	if ComfirmRepairAll() then
		self:Hide();
	end
end

function ComfirmRepairAll()
	if curRepairAllCost == nil or allRepairItems == nil then
		return false;
	end
	if not GameCoreHelper.CheckInventoryForItems(curRepairAllCost) then
		ShowToastInfo(GetGameString("GameEventExecutor_ExecuteCmdLine_3"), 3);
		return false;
    end
	for index=0,curRepairAllCost.Count-1 do
		local tagMat = curRepairAllCost[index];
		GameCoreHelper.RemoveItemsFormPlayerInv(tagMat.itemID, tagMat.itemCount, false);
	end
	for i=0,allRepairItems.Count-1 do
		local tagItem = allRepairItems[i];
		GameCoreHelper.RepairItem(tagItem);
	end
	UpdateAllRepairItems();
	return true
end

function onTimerTickUpdate()

end

function UpdateAllRepairItems()
	lvItemsList.numItems = 0;
	curRepairAllCost = GameCoreHelper.GetEmptyGameItemList();
	allRepairItems = gameWorld:GetRepairableEquipItems();
	if allRepairItems.Count > 0 then
		for index=0,allRepairItems.Count-1 do
			local tagRepairEquip = allRepairItems[index];
			AddRepairItemBox(tagRepairEquip)
		end
		ctlMatResBox:UpdateValsByItemList(curRepairAllCost, true);

		btnRepairAll.visible = true;
	else
		btnRepairAll.visible = false;
	end

	--ctlResBox:UpdateNums()
end

function AddRepairItemBox(tagRepairEquip)
	local newItemObj = lvItemsList:AddItemFromPool().asCom;
	if newItemObj ~= nil then
		local compBindInfo = newItemObj.data;
		if compBindInfo == nil then
			compBindInfo = {};
			compBindInfo.txtInfo = newItemObj:GetChild("title").asTextField;
			compBindInfo.txtDuration = newItemObj:GetChild("duration").asTextField;
			compBindInfo.ctlResBox = CreateStandardResBoxByList(newItemObj:GetChild("mat_list").asList, false);
			compBindInfo.imgIcon = newItemObj:GetChild("icon").asLoader;
			compBindInfo.ctlRarity = newItemObj:GetController("rarity");
			compBindInfo.bindBtn = newItemObj:GetChild("btn_repair").asButton;
			compBindInfo.bindBtn.onClick:Set(function()
				OnRepairTagItem(compBindInfo);
			end);
			newItemObj.data = compBindInfo;
		end

		compBindInfo.bindItem = tagRepairEquip;
		compBindInfo.imgIcon.url = CS.GUIHelper.GetItemIconPathByName(tagRepairEquip:GetItemIconFile());
		compBindInfo.txtInfo.text = CS.GUIHelper.ConvertUGUIStr(tagRepairEquip:GetItemName());
		compBindInfo.txtDuration.text = StringFormat(GetGameString("RepairWin_CurDurationVal"),
												tagRepairEquip.currentDurability, tagRepairEquip.MaxDurability);
		local itemRarity = tagRepairEquip:GetItemQuality();
		compBindInfo.txtInfo.color = tagRepairEquip:GetItemQualityColor();
		compBindInfo.ctlRarity.selectedIndex = itemRarity;
		compBindInfo.matList = tagRepairEquip:GetFixCost();

		if compBindInfo.matList ~= nil then
			compBindInfo.ctlResBox:UpdateValsByItemList(compBindInfo.matList, true);
			for index=0,compBindInfo.matList.Count-1 do
				local tagMatItem = compBindInfo.matList[index];
				CS.GameTools.AddItemToListNoRepeat(curRepairAllCost, tagMatItem);
			end
		end
	end
end

function OnRepairTagItem(_tagBindInfo)
	if _tagBindInfo == nil or _tagBindInfo.bindItem == nil or _tagBindInfo.matList == nil then
		return;
	end
	if not GameCoreHelper.CheckInventoryForItems(_tagBindInfo.matList) then
		ShowToastInfo(GetGameString("GameEventExecutor_ExecuteCmdLine_3"), 3);
		return;
    end
	for index=0,_tagBindInfo.matList.Count-1 do
		local tagMat = _tagBindInfo.matList[index];
		GameCoreHelper.RemoveItemsFormPlayerInv(tagMat.itemID, tagMat.itemCount, false);
	end
	GameCoreHelper.RepairItem(_tagBindInfo.bindItem);
	UpdateAllRepairItems();
end
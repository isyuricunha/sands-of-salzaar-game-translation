require("GameTools")
require("GameMath")

--require("LuaPanda").start("127.0.0.1",8818)

----------------------------------------------全局变量--------------------------------------------------
CurGameWorld = nil

--好感度上下限
RelationshipMaxVal = 100
RelationshipMinVal = -100

--好感度对象类型枚举
RepTagType_Camp = 0
RepTagType_Role = 1
RepTagType_Place = 2

--缓存变量默认值（OnGameStart时会被重置）
CampRepWantedLine = 0
CampRepInWarLine = -10

--自动宣战好感度阈值
CampRelationAutoDeclareWarLine = -10

--叛乱系统是否开启
IsRebelSystemON = false;

--是否开启比武大会逻辑
IsEnableTournament = false;

--队伍成员离队警告计时器
curTeamRlAlertTimer = 0;

RES_ID_MONEY = "金钱"
RES_ID_WOOD = "木材"
RES_ID_IRON = "铁石"
RES_ID_JADE = "玉石"

DipEventGoodwill = 2    --外交行为：友善
DipEventDeclareWar = 3  --外交行为：宣战
DipEventAlly = 4        --外交行为：同盟
DipEventBreakAlly = 5   --外交行为：终止同盟
DipEventTruce = 6       --外交行为：停战

---* 农民起始金钱 - 按月累加
FarmerStartMoney = { 250, 300, 400, 600, 800, 1000 }
---* 农民购买特产最大值 (负值为无限)
FarmerBuyProductMaxCount = 10

---* 商队起始金钱 - 按月累加
CaravanStartMoney = { 350, 500, 700, 900, 1200, 1500 }
---* 商队购买特产最大值 (负值为无限)
CaravanBuyProductMaxCount = 10

----------------------------------------------变量缓存--------------------------------------------------

local GameCoreHelper = CS.GameCoreHelper

local StringFormat = GameCoreHelper.StringFormat
local GetGameString = GameCoreHelper.GetGameString
local ShowGameMsg = GameCoreHelper.ShowGameMsg
local GetRandomNum = GameCoreHelper.GetRandomNum
local GetRandomInt = GameCoreHelper.GetRandomInt
local GetRandomBool = GameCoreHelper.GetRandomBool

---------------------------------------------游戏关键接口--------------------------------------------------



--每次进入游戏（或是载入游戏后）会调用此接口
function OnGameStart()
    CurGameWorld = GameCoreHelper.GetCurGameWorld();

    --以下阵营声望线缓存值仅影响消息显示，核心逻辑请修改初始设定表中的相关字段
    CampRepWantedLine = CurGameWorld.campRepValWantedLine;
    CampRepInWarLine = CurGameWorld.campRepValInWarLine;

    IsRebelSystemON = CS.GameConfig.IsRebelSystemON;
    IsEnableTournament = CS.GameConfig.IsEnableTournament;
    curTeamRlAlertTimer = 0;
end

--实现自定义的字符串查询
function GetLuaStringVal(valKey, contextArgVal)
    if valKey == "test" then
        return "ok"
    end
    return ""
end

--实现自定义的整形查询
function GetLuaIntVal(valKey, contextArgVal)
    if string.find(valKey,'dip_money=') ~= nil then
        local playerCamp = GameCoreHelper.GetPlayerRole():GetRoleCamp()
        local tagCamp = contextArgVal.CurTagCamp
        if playerCamp ~= nil and tagCamp ~= nil then
            local queryKey = string.sub(valKey, 11)
            if queryKey == "goodwill_min" then
                return GetDipGoodwillMoneyMin(playerCamp, tagCamp)
            elseif queryKey == "ally_min" then
                return GetDipAllyMoneyMin(playerCamp, tagCamp)
            elseif queryKey == "truce_min" then
                return GetDipTruceMoneyMin(playerCamp, tagCamp)
            end
        end
    elseif valKey == "和解赔款" then
        if contextArgVal.CurTagCamp ~= nil then
            return GetCompromiseMoney(contextArgVal.CurTagCamp)
        end
    end
    return 0
end

-------------------------------------------好感度及声望相关-------------------------------------------------

function DebugTest1()
    local tagCamp = GameCoreHelper.GetGameCamp("蛮牛")
    tagCamp:SendEnvoy(DipEventGoodwill, "自建势力", "8000")
end
function DebugTest2()
    local tagCamp = GameCoreHelper.GetGameCamp("蛮牛")
    tagCamp:SendEnvoy(DipEventAlly, "自建势力", "10000")
end
function DebugTest3()
    local tagCamp = GameCoreHelper.GetGameCamp("蛮牛")
    tagCamp:SendEnvoy(DipEventBreakAlly, "自建势力", "")
end
function DebugTest4()
    local tagCamp = GameCoreHelper.GetGameCamp("蛮牛")
    tagCamp:SendEnvoy(DipEventDeclareWar, "自建势力", "")
end
function DebugTest5()
    local tagCamp = GameCoreHelper.GetGameCamp("蛮牛")
    tagCamp:SendEnvoy(DipEventTruce, "自建势力", "30000")
end

--得到角色角色声望访问的对应KEY值
function GetRoleRepSaveKey(targetType, tagID)
    return targetType .. "_" .. tagID
end

--获取角色对应的声望 opRole:操作的对象角色 targetType: 0：阵营 1：角色 2：地点  tagID:对象ID
function GetRoleRep(opRole, targetType, tagID)
    if targetType == RepTagType_Camp then
        if opRole:IsTagCampLeader(tagID) then
            --当目标是阵营领袖时默认最大声望
            return RelationshipMaxVal
        end
    elseif targetType == RepTagType_Role then
        --人物之间关系因为加入了NPC多维关系现已转入特定接口处理
        return GameCoreHelper.GetRoleRelationVal(opRole.roleID, tagID);
    end
    local repKey = GetRoleRepSaveKey(targetType, tagID)
    return opRole:GetAbstractVal(repKey)
end

--游戏内为角色改变对应声望的接口 opRole:操作的对象角色 targetType: 0：阵营 1：角色 2：地点
--tagID:对象ID  opVal:操作值  isAdd:是否改变模式（false为直接设置）
--isNotify:是否发送游戏内通知 isChainedMode:是否关联模式(改变所有关联对象)
function SetRoleRep(opRole, targetType, tagID, opVal, isAdd, isNotify, isChainedMode)
    if opRole == nil or IsEmptyOrNilStr(tagID) then
        return
    end
    if targetType == 1 then
        --人物之间关系因为加入了NPC多维关系现已转入特定接口处理
        local tagRole = GameCoreHelper.GetRole(tagID);
        if tagRole ~= nil then
            if isAdd then
                GameCoreHelper.ChangeRoleRelationVal(opRole, tagRole, opVal, isChainedMode);
            else
                GameCoreHelper.SetRoleRelationVal(opRole, tagRole, opVal);
            end
        end
        return
    end
    local repKey = GetRoleRepSaveKey(targetType, tagID)
    local oldVal = opRole:GetAbstractVal(repKey)
    local delta = 0
    local newVal = oldVal
    if isAdd then
        delta = opVal
        --根据角色属性字段影响更改值
        if delta > 0 then
            if targetType == RepTagType_Role then
                delta = delta * (1.0 + opRole:GetRoleStat("dip_角色好感度") / 100.0)
            elseif targetType == RepTagType_Camp or targetType == RepTagType_Place then
                delta = delta * (1.0 + opRole:GetRoleStat("dip_势力好感度") / 100.0)
            end
        else
            if targetType == RepTagType_Role then
                local val = opRole:GetRoleStat("dip_避免降低角色好感度概率")
                if val > 0 and GetRandomBool(val) then
                    delta = 0
                end
            elseif targetType == RepTagType_Camp or targetType == RepTagType_Place then
                local val = opRole:GetRoleStat("dip_避免降低势力好感度概率");
                if val > 0 and GetRandomBool(val) then
                    delta = 0
                end
            end
        end
        --最终结果
        newVal = oldVal + delta
    else
        newVal = opVal
    end
    newVal = math.floor(Clamp(newVal, RelationshipMinVal, RelationshipMaxVal))
    delta = math.floor(newVal - oldVal)
    if newVal == oldVal then
        return
    end
    opRole:SetAbstractVal(repKey, newVal)
    if opRole:IsPlayer() then
        local msgInfo
        --主角对阵营声望影响
        if targetType == RepTagType_Camp then
            local camp = GameCoreHelper.GetGameCamp(tagID);
            if camp == nil then
                DebugError("错误：不存在的阵营,id=" .. tagID)
                return
            else
                if isNotify then
                    local campName = camp:GetCampName()
                    if delta > 0 then
                        msgInfo = StringFormat(GetGameString("player_rep_add"), campName, delta, newVal);
                    else
                        msgInfo = StringFormat(GetGameString("player_rep_minus"), campName, -delta, newVal);
                    end
                    ShowGameMsg(msgInfo, 0)
                    if oldVal >= CampRepWantedLine and newVal < CampRepWantedLine then
                        ShowGameMsg(StringFormat(GetGameString("player_camprep_wanted"), campName), 1)
                    elseif oldVal >= CampRepInWarLine and newVal < CampRepInWarLine then
                        ShowGameMsg(StringFormat(GetGameString("player_camprep_inwar"), campName), 1)
                    elseif oldVal <= CampRepWantedLine and newVal > CampRepWantedLine then
                        ShowGameMsg(StringFormat(GetGameString("player_camprep_no_wanted"), campName), 0)
                    end
                end
                if isChainedMode and camp:EnableAutoChangeDip() then
                    local allCamps = GameCoreHelper.GetAllGameCamps()
                    for i=0,allCamps.Count-1 do
                        local c = allCamps[i]
                        local tagRl = GameCoreHelper.GetCampRelation(tagID, c.CampID)
                        if (c:IsPlayerOwnedCamp()) then --玩家自己的阵营不受影响
                        elseif (c.CampID == tagID) then --当前势力
                        elseif (not c:EnableAutoChangeDip()) then --过滤一些不受外交影响的阵营
                        elseif (tagRl ~= nil  and tagRl.curState ~= 2) then --阿晨：非结盟势力
                        else
                            local rl = GameCoreHelper.GetCampRelation(c.CampID, tagID);
                            if rl ~= nil then
                                local friendlyVal = rl.friendlyVal    --当前的友好度
                                local changeValue = math.floor(delta * friendlyVal * GetRandomNum(0.5, 0.75) / RelationshipMaxVal)
                                if changeValue ~= 0 then
                                    SetRoleRep(opRole, RepTagType_Camp, c.CampID, changeValue, true, isNotify, false)
                                end
                            end
                        end
                    end
                end
            end
        --主角对地点声望影响
        elseif targetType == RepTagType_Place then
            local tagPlace = GameCoreHelper.GetGamePlace(tagID);
            if tagPlace == nil then
                DebugError("调用了不存在的地点，id=" .. tagID);
            else
                tagPlace:PlayerActive();
                if isNotify then
                    if delta > 0 then
                        msgInfo = StringFormat(GetGameString("RoleRuntimeData_SetRep"), tagPlace:GetPlaceName(), delta, newVal);
                    else
                        msgInfo = StringFormat(GetGameString("RoleRuntimeData_SetRep_1"), tagPlace:GetPlaceName(), -delta, newVal);
                    end
                    ShowGameMsg(msgInfo, 0);
                end

                --检查对应的触发器事件
                local argVal = GameCoreHelper.CreateEmptyRuntimeArgVal();
                argVal.CurTagPlace = tagPlace;
                argVal.argIntVal1 = newVal;
                if (newVal >= oldVal) then
                    GameCoreHelper.CheckGameTrigger("on_place_rep_up", "", tagID, argVal, false);
                else
                    GameCoreHelper.CheckGameTrigger("on_place_rep_down", "", tagID, argVal, false);
                end
            end
        --主角对角色关系影响
        elseif targetType == RepTagType_Role then
            local tagRole = GameCoreHelper.GetRole(tagID);
            if tagRole == nil then
                DebugError("调用了不存在的人物,id=" .. tagID);
            else
                if tagRole:IsTemplateRole() then
                    --模板人物不可改变关系
                    return
                end
                tagRole:SetPlayerContactActive()          --将此角色标记为社交激活状态
                if isNotify then
                    if (delta > 0) then
                        msgInfo = StringFormat(GetGameString("person_fv_add"), tagRole:GetRoleName(), delta, newVal);
                    else
                        msgInfo = StringFormat(GetGameString("person_fv_minus"), tagRole:GetRoleName(), -delta, newVal);
                    end
                    ShowGameMsg(msgInfo, 0)
                end
            end
        end
    end
end

--个人与AI势力关系和解所需资源计算
function GetCompromiseMoney(tagCamp)
    local needMoney = 0
    local repVal = tagCamp:GetPlayerRepInCamp()
    if repVal >= -50 then
        needMoney = -repVal * 50
    else
        --关系低于-50罚金加倍
        needMoney = (-repVal - 50) * 100 + 2500
    end
    if needMoney < 100 then
        needMoney = 100
    end
    return needMoney
end

--给NPC送礼物涨好感度的逻辑
function GivePresentLogic(contextArgVal)
    local itemList = GameCoreHelper.GetLastSeledItems()
    local tagRole = GameCoreHelper.GetRole(contextArgVal.CurTagRoleID)
    local playerRole = GameCoreHelper.GetPlayerRole()
    local retVal = 0
    if itemList ~= nil and tagRole ~= nil and itemList.Count > 0 then
        local item = itemList[0]
        local likeLV = GameCoreHelper.QualifyAsPresentWithLikeLevel(item, tagRole);
        local FVChangeUnit = 10;
        local fvChangeUnitTag = tagRole:GetTagValue("FVChangeUnit")
        if not IsEmptyOrNilStr(fvChangeUnitTag) then
            FVChangeUnit = tonumber(fvChangeUnitTag)
        end
        local FVChange = 0;
        if likeLV >= 0 then
            FVChange = math.floor((likeLV + 1) * FVChangeUnit)
        end

        CurRoleFV = GetRoleRep(playerRole, RepTagType_Role, tagRole.roleID);
        if CurRoleFV < 0 then
            CurRoleFV = CurRoleFV * -1
        end

        if CurRoleFV >= 20 then
            CurRoleFV = math.floor(Clamp((CurRoleFV * 2), 40, 99))
        end

        CurRoleFV2 = math.floor(Clamp((100-CurRoleFV), 10, 101))

        FVChange =  math.floor(FVChange * CurRoleFV2 /100)
        FVChange = math.max(FVChange, 1)

        --tagRole.LastPresentDay = CurGameWorld.curGameTime;

        GameCoreHelper.RemoveItemsFormPlayerInv(item.itemID, 1);

        SetRoleRep(playerRole, RepTagType_Role, tagRole.roleID, FVChange, true, true, true);

        tagRole.LastPresentDay = math.floor(CurGameWorld.curGameTime);
    end
    contextArgVal.curResultVal = retVal
end

-------------------------------------------游戏通用逻辑-------------------------------------------------

--游戏中游戏时间单位执行的逻辑 （注册在game_hour_logics接口事件表中）
--curDay:当前游戏天数 curH:当前游戏内小时单位（每天12单位）
function OnGameHourLogic(curDay, curH)
    if curH == 7 then
        --每天固定时间检测队伍成员好感度
        PlayerPartyMemberLeaveCheck(curDay);
    elseif curH == 9 then
        --阵营势力自定义逻辑遍历
        CampDailyUpdateLogic();
    end
end

function PlayerPartyMemberLeaveCheck(curDay)
    local checkDay = false;
    if curDay % 7 == 3 then
        checkDay = true;
    end
    if checkDay or curTeamRlAlertTimer == 0 then
        local playerTeam = GameCoreHelper.GetPlayerTeam();
        if playerTeam ~= nil and playerTeam:GetCurRoleCount() > 1 then
            local roleList = playerTeam.rolesInTeam;
            local playerRole = GameCoreHelper.GetPlayerRole();
            local tagRole;
            local curFv;
            local leaveProb;
            local badPartners;
            local goodPartners;
            local pSubRole;
            local subFv;
            for i=0,roleList.Count-1 do
                tagRole = roleList[i];
                if not tagRole:IsPlayer() and tagRole.roleState == 0 and not tagRole:IsNoBetray()
                    and tagRole:IsLeaveTeamEnable() and tagRole:IsEnableExpel() then
                    badPartners = 0;
                    goodPartners = 0;
                    for i2=0,roleList.Count-1 do
                        pSubRole = roleList[i2];
                        if tagRole ~= pSubRole and not pSubRole:IsPlayer() and pSubRole.roleState == 0 then
                            subFv = tagRole:GetRelationValWithOtherRole(pSubRole.roleID);
                            if subFv < -10 then
                                badPartners = badPartners + 1;
                            elseif subFv > 30 then
                                goodPartners = goodPartners + 1;
                            end
                        end
                    end
                    --获取当前好感值
                    curFv = tagRole:GetRelationValWithOtherRole(playerRole.roleID);
                    --离队概率值=-与主角的关系+（关系<-10的队友数量）*10-（关系>30的队友数量）*10
                    leaveProb = (-curFv + badPartners*10 - goodPartners*10);
                    if checkDay and leaveProb > 0 and GetRandomBool(leaveProb) then
                        --触发离队事件
                        local isTrigged = false;
                        local curRtVals = GameCoreHelper.CreateEmptyRuntimeArgVal();
	                    curRtVals.CurTagRoleID = tagRole.roleID;
                        local tagTrigger = CurGameWorld:GetBindTrigger("npc_leave_party", "", "", curRtVals);
                        if (tagTrigger ~= nil) then
                            if (CurGameWorld:CheckTrigger(tagTrigger.Key, curRtVals)) then
                                isTrigged = true;
                            end
                        end
                        if not isTrigged then
                            --默认处理，直接离队
                            CS.WorldAIHelper.WorldAI_NpcLeaveCamp(tagRole);
                            local msgInfo = GameCoreHelper.StringFormat(GetGameString("lua_script_str_100"), tagRole:GetRoleName());
                            ShowGameMsg(msgInfo, 1);
                        end
                        break;
                    elseif leaveProb >= 50 then
                        --离队概率大于等于50%时发出警告
                        local msgInfo = GameCoreHelper.StringFormat(GetGameString("lua_script_str_101"), tagRole:GetRoleName());
                        ShowGameMsg(msgInfo, 1);
                    end
                end
            end
        end
    end
    curTeamRlAlertTimer = curTeamRlAlertTimer + 1;
    if curTeamRlAlertTimer >= 3 then
        --每3天警告一次
        curTeamRlAlertTimer = 0;
    end
end

function CampDailyUpdateLogic()
    local allCamps = GameCoreHelper.GetAllGameCamps()
    local tagCamp;
    for i=0,allCamps.Count-1 do
        tagCamp = allCamps[i]
        if IsEnableTournament then
            --搏击大会检定逻辑
            if not tagCamp:IsStoryCamp() and tagCamp.CurState == 0 then
                CS.RoleLogic.CheckTournamentFightUpdate(tagCamp);
            end
        end
    end
end

-------------------------------------------阵营逻辑相关-------------------------------------------------

--阵营每日逻辑（注册在camp_daily_logics接口事件表中）
--tagCamp:目标阵营 curDay:当前逻辑的游戏内天数
function OnCampDailyLogic(tagCamp, curDay)

    --阵营内置每日逻辑（给手下发工资等，忠诚度改变等）
    tagCamp:CampDailyLogicInner(curDay)

    --每隔几天重新计算势力当前实力
    if curDay % 3 == 0  then
        tagCamp:UpdateCurCampPower();
    end

    if not tagCamp:IsActiveCamp() then
        --非活跃状态的阵营不执行该逻辑
        return
    end

    if tagCamp:IsAIDelegate() then
        if curDay % 10 == 0  then
            --重新分配本势力下的人员
            tagCamp:AI_ReArrangeAllCampRoles();
        end
        if curDay % 3 == 0  then
            if not CurGameWorld.isUnchangedDiplomaticRl then
                --改变外交策略逻辑
                if not tagCamp:IsHidden() then
                    --外交策略调整
                    OnCampDiplomaticDynamicChange(tagCamp);
                end
            end
        end

        if CurGameWorld.ai_dailyfight_period > 0 then
            if curDay % CurGameWorld.ai_dailyfight_period == tagCamp.FightDay then
                --根据AI强度计算概率
                local passProb = CurGameWorld:GetAILevelRatio() * 0.3 + 0.2
                if GetRandomBool(passProb * 100.0) then
                    --日常讨伐
                    tagCamp:OnDailyFight();
                end
            end
        end

        --每3天进行一次招募
        if curDay % 3 == 0 then
            if tagCamp:GetLeader() ~= nil and tagCamp:IsEnableRecruitHero() then
                --AI尝试招募在野英雄和俘虏
                local passProb = CurGameWorld:GetAILevelRatio() * 0.4 + 0.2
                if GetRandomBool(passProb * 100.0) then
                    tagCamp:AIRecruitNewHero()
                end
            end
        end
    end

end

--AI势力动态改变外交关系逻辑
function OnCampDiplomaticDynamicChange(tagCamp)
    if not tagCamp:IsActiveCamp() then
        return
    end

    if not tagCamp:EnableAutoChangeDip() then
        return
    end

    --根据当前AI等级因数随机跳过外交关系改变逻辑
    local rlChangeRate = 20.0 + CurGameWorld:GetAILevelRatio() * 30.0
    if not GetRandomBool(rlChangeRate) then
        return
    end

    --***[TODO]:此处需要修改调整各种概率值***--
    --随机动态外交关系改变
    local neutralCamps = GameCoreHelper.GetEmptyCampsDipInfoList()
    local allyCamps = GameCoreHelper.GetEmptyCampsDipInfoList()
    local enemyCamps = GameCoreHelper.GetEmptyCampsDipInfoList()

    local allCamps = GameCoreHelper.GetAllGameCamps()
    local camp
    local myPower = tagCamp.CurPower * 1.0
    local targetPower
    local myLeader = tagCamp:GetLeader()
    local tagLeader
    local scoreFactor
    local roleRepFactor
    local tagRlState
    local tagRlFv
    local giftMoneyMin
    local giftMoneyMax
    local giftMoney
    for i=0,allCamps.Count-1 do
        camp = allCamps[i]
        if camp == tagCamp then
        elseif camp:GetLeader() == nil then
        elseif camp:EnableAutoChangeDip() then
            --玩家的外交关系不会随机变化
            local tagRl = GameCoreHelper.GetCampRelation(tagCamp.CampID, camp.CampID)
            tagRlState = 0
            tagRlFv = 0

            if tagRl ~= nil then
                tagRlState = tagRl.curState
                tagRlFv = tagRl.friendlyVal
            end

            if tagRlState == 1 then
                enemyCamps:Add(CS.CampsDipInfoData(camp, tagRlState, tagRlFv));
            elseif tagRlState == 2 then
                allyCamps:Add(CS.CampsDipInfoData(camp, tagRlState, tagRlFv));
            else
                neutralCamps:Add(CS.CampsDipInfoData(camp, tagRlState, tagRlFv));

                scoreFactor = 0
                roleRepFactor = 0

                --根据实力对比，如果对方实力比自己高，则更容易进入仇恨。
                --如果自己比对方高，则更容易进入友善。
                targetPower = camp.CurPower * 1.0
                if targetPower > myPower and myPower > 0 then
                    scoreFactor = targetPower/(myPower * 1.5)
                elseif myPower > targetPower and targetPower > 0  then
                    scoreFactor = myPower/(targetPower * 1.5)
                end
                scoreFactor = Clamp(scoreFactor - 1.0, 0, 1)

                --首领之间的私人关系的修正因子
                tagLeader = camp:GetLeader()
                if myLeader ~= nil and tagLeader ~= nil then
                    roleRepFactor = Clamp(GetRoleRep(myLeader, RepTagType_Role, tagLeader.roleID), 0, 1)
                end

                local rlChangeValue = math.floor((GetRandomNum(-1.0, 1.0) * 0.4 + scoreFactor * 0.3 + roleRepFactor * 0.3) * 6)
                if rlChangeValue ~= 0 then
                    SetCampRl(tagCamp.CampID, camp.CampID, -1, 1, rlChangeValue, false)
                end
            end
        end
    end

    if (not tagCamp:GetEnvoyEnable()) then
        return
    end

    local tagCampDip
    local fdProb
    --AI外交资源消耗修正
    local aiResFactor = 0.3
    local curMoney = myLeader:GetResourceNum(RES_ID_MONEY, aiResFactor)
    --AI等级影响概率
    local aiLevelRatio = (0.4 + CurGameWorld:GetAILevelRatio() * 0.3)
    local aiLevelRatioInverse = 2.0 - aiLevelRatio
    for i=0,neutralCamps.Count-1 do
        tagCampDip = neutralCamps[i]
        -- 计算敌方敌对阵营数量
        local tagenemyCamps = GameCoreHelper.GetEmptyCampsDipInfoList()
        local tagallCamps = GameCoreHelper.GetAllGameCamps()
        local camptag
        local tagtagRlState
        local tagtagRlFv
        for i=0,tagallCamps.Count-1 do
            camptag = tagallCamps[i]
            if camptag == tagCamp then
            elseif camptag:GetLeader() == nil then
            elseif camptag:EnableAutoChangeDip() then
                --玩家的外交关系不会随机变化
                local tagRltag = GameCoreHelper.GetCampRelation(tagCampDip.CampID, camptag.CampID)
                tagtagRlState = 0
                tagtagRlFv = 0

                if tagRltag ~= nil then
                    tagtagRlState = tagRltag.curState
                    tagtagRlFv = tagRltag.friendlyVal
                end

                if tagtagRlState == 1 then
                    tagenemyCamps:Add(CS.CampsDipInfoData(camptag, tagtagRlState, tagtagRlFv));
                end
            end
        end
        -- 计算敌方敌对阵营数量tagenemyCamps.Count


        --计算需要进行宣战的外交对象，最多同时宣战2个国家，并且只会宣战弱者

        if enemyCamps.Count <= 2 and tagCampDip.bindCamp.CurPower * (Clamp((10 - tagenemyCamps.Count), 1, 10)) /10 < myPower * 1  and tagCampDip.campFv < 20 then
            local warProb = (-tagCampDip.campFv + 50) * (tagCamp:GetCampPojo().prob_invasion / 100.0 * aiLevelRatio)
            if warProb > 0 and GetRandomBool(warProb) then
                tagCamp:SendEnvoy(DipEventDeclareWar, tagCampDip.bindCamp.CampID, "");
                return
            end
        end



        --AI同盟逻辑判断
        if tagCampDip.campFv > 30 and allyCamps.Count < 2 then
            fdProb = Clamp(tagCampDip.campFv / 100.0, 0, 1) * aiLevelRatioInverse  * 100.0
            if GetRandomBool(fdProb * 0.5) then --阿晨从0.2改为0.5
                giftMoneyMin = GetDipAllyMoneyMin(tagCamp, tagCampDip.bindCamp)
                aiResFactor = 0.3
                if curMoney > giftMoneyMin then
                    giftMoneyMax = giftMoneyMin * 2
                    giftMoney = Clamp(GetRandomInt(giftMoneyMin, giftMoneyMax + 1), giftMoneyMin, curMoney)
                    --阿晨：计算结盟对象的盟友数量
                    local allCamps = GameCoreHelper.GetAllGameCamps()
                    local tagcampallyCamps = GameCoreHelper.GetEmptyCampsDipInfoList()
                    for i=0,allCamps.Count-1 do
                        curtagcamp = allCamps[i]
                        if curtagcamp == tagCampDip.bindCamp then
                        elseif curtagcamp:GetLeader() == nil then
                        elseif curtagcamp:EnableAutoChangeDip() then
                            --玩家的外交关系不会随机变化
                            local curtagRl = GameCoreHelper.GetCampRelation(tagCampDip.bindCamp.CampID, curtagcamp.CampID)
                            curtagRlState = 0
                            curtagRlFv = 0

                            if curtagRl ~= nil then
                                curtagRlState = curtagRl.curState
                                curtagRlFv = curtagRl.friendlyVal
                            end
                            if curtagRlState == 2 then
                                tagcampallyCamps:Add(CS.CampsDipInfoData(curtagcamp, curtagRlState, curtagRlFv));
                            end
                        end
                    end
                    --阿晨：结盟对象的盟友数量小于2时
                    if tagcampallyCamps.Count >= 2 then
                        --DebugError("存在两个以上盟友！！！！")
                    end
                    if tagcampallyCamps.Count < 2 then
                       tagCamp:SendEnvoy(DipEventAlly, tagCampDip.bindCamp.CampID, tostring(giftMoney))
                       myLeader:ChangeResourceNum(RES_ID_MONEY, -giftMoney, false, aiResFactor)
                       return
                    end
                end
            end
        end

        --AI只会攀附实力高于自己0.8倍以上的势力
        if tagCampDip.bindCamp.CurPower > myPower * 0.8 and myPower > 0 then
            fdProb = Clamp(tagCampDip.bindCamp.CurPower/(myPower * 0.8) - 1.0, 0, 1) * aiLevelRatio * 100.0
            if fdProb > 0 and GetRandomBool(fdProb * 0.5) then
                giftMoneyMin = GetDipGoodwillMoneyMin(tagCamp, tagCampDip.bindCamp)
                if curMoney > giftMoneyMin then
                    giftMoneyMax = giftMoneyMin * 3
                    giftMoney = Clamp(GetRandomInt(giftMoneyMin, giftMoneyMax + 1), giftMoneyMin, curMoney)
                    tagCamp:SendEnvoy(DipEventGoodwill, tagCampDip.bindCamp.CampID, tostring(giftMoney))
                    myLeader:ChangeResourceNum(RES_ID_MONEY, -giftMoney, false, aiResFactor)
                    return
                end
            end
        end
    end

    --计算需要进行终止同盟的外交对象
    for i=0,allyCamps.Count-1 do
        tagCampDip = allyCamps[i]
        if tagCampDip.campFv < 50 then
            fdProb = Clamp((50 - tagCampDip.campFv) / 50.0, 0, 1) * aiLevelRatio * 100.0
            if GetRandomBool(fdProb * 0.2) then
                tagCamp:SendEnvoy(DipEventBreakAlly, tagCampDip.bindCamp.CampID, "");
                return
            end
        end
    end

    --计算需要进行停战的外交对象
    for i=0,enemyCamps.Count-1 do
        tagCampDip = enemyCamps[i]
        if tagCampDip.bindCamp.CurPower > myPower * 0.7 then
            fdProb = Clamp(tagCampDip.bindCamp.CurPower/(myPower * 0.7) - 1.0, 0, 1) * enemyCamps.Count * aiLevelRatioInverse * 100
            if fdProb > 0 and GetRandomBool(fdProb * 0.5) then
                giftMoneyMin = GetDipTruceMoneyMin(tagCamp, tagCampDip.bindCamp)
                if curMoney > giftMoneyMin then
                    giftMoneyMax = giftMoneyMin * 3
                    giftMoney = Clamp(GetRandomInt(giftMoneyMin, giftMoneyMax + 1), giftMoneyMin, curMoney)
                    tagCamp:SendEnvoy(DipEventTruce, tagCampDip.bindCamp.CampID, tostring(giftMoney));
                    myLeader:ChangeResourceNum(RES_ID_MONEY, -giftMoney, false, aiResFactor)
                    return
                end
            end
        end
    end

end

--NPC叛乱系统判定逻辑
function OnCampRebelCheck(tagCamp, curDay)
    if not IsRebelSystemON then
        return;
    end
    --保持每周判定一次，各势力尽量交错开
    if curDay % 7 ~= tagCamp.campIndex % 7  then
        return;
    end

    --遍历势力成员
    local tagRole;
    local isPlayerCamp = false;
    local leaderRole = tagCamp:GetLeader();
    local playerTeam = nil;
    if leaderRole ~= nil then
        if leaderRole:IsPlayer() then
            isPlayerCamp = true;
            playerTeam = GameCoreHelper.GetPlayerTeam();
        end
        local curFv;
        local inPlayerTeam;
        local bigCityCount;
        local allCampRoles = tagCamp:GetAllCampRolesSnapshot();
        for i=0,allCampRoles.Count-1 do
            tagRole = allCampRoles[i];
            inPlayerTeam = false;
            if playerTeam ~= nil and tagRole.whereType == 2 and playerTeam:ContainsRole(tagRole) then
                inPlayerTeam = true;
            end
            if tagRole:GetRoleCamp() == tagCamp and tagRole ~= leaderRole and tagRole.roleState == 0
                and not tagRole:IsPlayer() and not tagRole:IsNoBetray() then
                --获取当前好感值
                curFv = tagRole:GetRelationValWithOtherRole(leaderRole.roleID);

                if isPlayerCamp then
                    if inPlayerTeam then

                    else
                        local nobleInfo = tagRole:GetNobilityRankInfo();
                        if nobleInfo ~= nil then
                            if nobleInfo.rank >= 2 then
                                --玩家阵营的检测领地数量，高于2级爵位但是领地数量不够的人会不满
                                local fiefCount = tagRole:GetAllFiefCount();
                                local changeVal = (nobleInfo.rank - fiefCount * 2) * 2;
                                if changeVal > 0 then
                                    changeVal = -changeVal;
                                    leaderRole:ChangeRelationValWithOtherRole(tagRole, changeVal, false, false);
                                    if GameCoreHelper.IsEnableRoleRlLog() then
                                        local sInfo = tagRole:GetRoleName() .. " 因为未被赋予领地而对 " .. leaderRole:GetRoleName() .. " 心生不满，改变值=" .. changeVal;
                                        local logEvent = GameCoreHelper.LogRoleRlInfo(sInfo);
                                        logEvent:AddLogOpRole(leaderRole.roleID);
                                        logEvent:AddLogOpRole(tagRole.roleID);
                                    end
                                end
                            end
                        end
                    end
                else
                    --AI势力NPC暂时不处理

                end

                --当好感过低可能发生叛乱或者离开
                if not inPlayerTeam and curFv <= -30 then
                    bigCityCount = tagRole:GetFiefCount(1);
                    if bigCityCount > 0 then
                        --检查叛乱CD
                        if GameCoreHelper.IsCustomCDReady("NpcRebelEvent1") then
                            --大城数量不为0时可能叛乱
                            local prob = math.min((-20 - curFv)*bigCityCount, 70);
                            if prob > 0 and GetRandomBool(prob) then
                                --判定成功，发生叛乱
                                local rebelCamp = GameCoreHelper.RoleCreateNewCamp(tagRole, nil, nil);
                                if rebelCamp ~= nil then
                                    --叛乱成功后3周内不会再发生叛乱事件
                                    GameCoreHelper.SetCustomCD("NpcRebelEvent1", 21);
                                end
                            end
                        end
                    else
                        --判定离开概率
                        local prob = math.min((-20 - curFv), 50);
                        if prob > 0 and GetRandomBool(prob) then
                            --判定成功，NPC离开阵营
                            CS.WorldAIHelper.WorldAI_NpcLeaveCamp(tagRole);
                        end
                    end
                end
            end
        end
    end
end

function TestRoleRebel(contextArgVal, argStr)
    local args = SplitStr(argStr, ",")
    local _roleID = args[1]
    local _campName = args[2]

    local tagRole = GameCoreHelper.GetRole(_roleID);
    if tagRole ~= nil then
        GameCoreHelper.RoleCreateNewCamp(tagRole, _campName, nil);
    end
end

--新势力建立后调用接口  如新势力是从其他势力中叛离出来，则oldCamp不为空
function OnCreateNewCamp(newCamp, oldCamp)
    if newCamp == nil then
        return;
    end
    local newLeaderRole = newCamp:GetLeader();
    if newLeaderRole == nil then
        return;
    end
    local capitalPlace = newCamp:GetCampCapital();
    if (oldCamp ~= nil) then
        --改变关系
        GameCoreHelper.SetCampRl(newCamp.CampID, oldCamp.CampID, 1, true, -50, true);
        local oldLeader = oldCamp:GetLeader();
        if (oldLeader ~= nil) then
            local changeVal = -50;
            newLeaderRole:ChangeRelationValWithOtherRole(oldLeader, changeVal, true, true);

            if GameCoreHelper.IsEnableRoleRlLog() then
                local sInfo = oldLeader:GetRoleName() .. "因为 " .. newLeaderRole:GetRoleName() .. " 叛乱而关系改变，改变值=" .. changeVal;
                local logEvent = GameCoreHelper.LogRoleRlInfo(sInfo);
                logEvent:AddLogOpRole(oldLeader.roleID);
                logEvent:AddLogOpRole(newLeaderRole.roleID);
            end
        end
        local lordRole = nil;
        local tagPlace;
        for i=0,oldCamp.campPlaceList.Count-1 do
            tagPlace = oldCamp.campPlaceList[i];
            lordRole = tagPlace:GetLordRole();
            if (lordRole ~= nil) then
                if (oldLeader ~= lordRole) then
                    --其他领主关系跟着减
                    local changeVal = -20;
                    newLeaderRole:ChangeRelationValWithOtherRole(lordRole, changeVal, true, true);

                    if GameCoreHelper.IsEnableRoleRlLog() then
                        local sInfo = lordRole:GetRoleName() .. "因为 " .. newLeaderRole:GetRoleName() .. " 叛乱而关系改变，改变值=" .. changeVal;
                        local logEvent = GameCoreHelper.LogRoleRlInfo(sInfo);
                        logEvent:AddLogOpRole(lordRole.roleID);
                        logEvent:AddLogOpRole(newLeaderRole.roleID);
                    end
                end
            end
        end

        --检查NPC投靠判定
        local allRoleList = GameCoreHelper.GetAllGameRoles();
        local role = nil
        for i=0,allRoleList.Count-1 do
            role = allRoleList[i];
            if not role:IsTemplateRole() and role.roleState == 0 and role ~= oldLeader and not role:IsPlayer()
                and role ~= newLeaderRole and role:GetRoleCamp() ~= newCamp then
                --仅判定地点中的
                if role.whereType == 1 then
                    if (role:GetRoleCamp() == nil) then
                        --在野NPC投靠判定
                        local curFv = role:GetRelationValWithOtherRole(newLeaderRole.roleID);
                        if (curFv > 0) then
                            local prob = curFv;
                            if prob > 0 and GetRandomBool(prob) then
                                CS.RoleLogic.JoinNewCamp(role, newCamp, capitalPlace);
                            end
                        end
                    elseif (role:GetRoleCamp() == oldCamp) then
                        --原阵营英雄投靠判定
                        local curFv = role:GetRelationValWithOtherRole(newLeaderRole.roleID);
                        if (curFv >= 20) then
                            local leaderFv = 0;
                            if (oldLeader ~= nil) then
                                leaderFv = role.GetRelationValWithOtherRole(oldLeader.roleID);
                            end
                            local prob = curFv - leaderFv;
                            if prob > 0 and GetRandomBool(prob) then
                                CS.RoleLogic.JoinNewCamp(role, newCamp, capitalPlace);
                            end
                        end
                    end
                end
            end
        end
    end

    --如果是玩家势力直接满声望
    if newLeaderRole:IsPlayer() then
         SetRoleRep(newLeaderRole, RepTagType_Camp, newCamp.CampID, 100, false, false, false);
    end

    --显示消息
    local msgInfo;
    local campName = newCamp:GetCampName();
    local msgType = 0;
    if oldCamp == nil then
        if newLeaderRole:IsPlayer() then
            msgInfo = GameCoreHelper.StringFormat(GetGameString("game_msg_createcamp"), campName);
        else
            msgInfo = GameCoreHelper.StringFormat(GetGameString("lua_script_str_102"), newLeaderRole:GetRoleName(), campName);
        end
    else
        local oldCampName = oldCamp:GetCampName();
        if newLeaderRole:IsPlayer() then
            msgInfo = GameCoreHelper.StringFormat(GetGameString("lua_script_str_103"), oldCampName, campName);
        else
            local playerRole = GameCoreHelper.GetPlayerRole();
            if oldCamp == playerRole:GetRoleCamp() then
                msgType = 1;
            end
            msgInfo = GameCoreHelper.StringFormat(GetGameString("lua_script_str_104"), newLeaderRole:GetRoleName(), oldCampName, campName);
        end
    end
    ShowGameMsg(msgInfo, msgType);
end

--AI势力决定外交行为的判断(玩家处理外交行为逻辑通过处理 dip_event 触发器事件来决定)
function OnAIDecideDipEvent(execCamp, dipInfo)
    if dipInfo.fromCamp == nil or execCamp == nil then
        return
    end
    local successProp = 0.0
    local noNeedDecide = false
    local minMoney
    local tagRl = GameCoreHelper.GetCampRelation(execCamp.CampID, dipInfo.fromCamp.CampID)
    local campRlState = 0
    local tagRlFv = 0
    local myPower = execCamp.CurPower * 1.0 + 1.0

    if tagRl ~= nil then
        campRlState = tagRl.curState
        tagRlFv = tagRl.friendlyVal
    end
    local giftMoney = 0
    if not IsEmptyOrNilStr(dipInfo.argsVal) then
        giftMoney = tonumber(dipInfo.argsVal)
    end

    --AI等级影响概率
    local aiLevelRatio = 1.0
    local aiLevelRatioInverse = 1.0
    if dipInfo.fromCamp:IsPlayerOwnedCamp() then
        aiLevelRatio = (0.4 + CurGameWorld:GetAILevelRatio() * 0.3)
        aiLevelRatioInverse = 2.0 - aiLevelRatio
    end

    --**[TODO]:AI各种外交成功概率公式修改***--
    if dipInfo.dipType == DipEventGoodwill then
        --AI亲善同意概率
        minMoney = GetDipGoodwillMoneyMin(dipInfo.fromCamp, execCamp)
        dipInfo.resultRatio = Clamp(giftMoney / minMoney - 1.0, 0, 1)
        successProp = tagRlFv + 20.0 + dipInfo.resultRatio * 50.0 * aiLevelRatioInverse
        -- DebugError("亲善概率为," .. successProp)
    elseif dipInfo.dipType == DipEventDeclareWar then
        if campRlState == 1 then
            return
        end
        --宣战
        noNeedDecide = true
    elseif dipInfo.dipType == DipEventAlly then
        if campRlState ~= 0 then
            return
        end
        --AI结盟同意概率
        minMoney = GetDipAllyMoneyMin(dipInfo.fromCamp, execCamp)
        dipInfo.resultRatio = Clamp(giftMoney / minMoney - 1.0, 0, 1)
        local power_multi = Clamp(dipInfo.fromCamp.CurPower / myPower, 0.5, 2)
        successProp = ((tagRlFv - 30)/2 + dipInfo.resultRatio  * 30.0 * aiLevelRatioInverse) * power_multi
    elseif dipInfo.dipType == DipEventBreakAlly then
        if campRlState ~= 2 then
            return
        end
        --解除盟约
        noNeedDecide = true
    elseif dipInfo.dipType == DipEventTruce then
        if campRlState ~= 1 then
            return
        end
        --AI停战同意概率
        minMoney = GetDipTruceMoneyMin(dipInfo.fromCamp, execCamp)
        local power_multi = Clamp(dipInfo.fromCamp.CurPower / myPower, 0.5, 3)
        dipInfo.resultRatio = Clamp(giftMoney / minMoney - 1.0, 0, 1)
        successProp = (50 + tagRlFv + dipInfo.resultRatio * 100.0 * aiLevelRatioInverse) * power_multi --阿晨：加50作为基数
    else
        --其他概率
        successProp = 50.0
    end
    --词条影响
    if dipInfo.fromCamp ~= nil and dipInfo.fromCamp:GetLeader() ~= nil then
        successProp = successProp + dipInfo.fromCamp:GetLeader():GetRoleStat("dip_亲和力")
    end

    local dipResult = false
    if noNeedDecide or GetRandomBool(successProp) then
        dipResult = true
    end

    OnDipEventCallback(dipResult, dipInfo)
end

--执行外交事件处理结果接口
function OnDipEventCallback(dipResult, dipInfo)
    if dipInfo.isDecided then
        return
    end
    if dipInfo.fromCamp == nil or dipInfo.execCamp == nil then
        return
    end
    local tagRl = GameCoreHelper.GetCampRelation(dipInfo.fromCamp.CampID, dipInfo.execCamp.CampID)
    local campRlState = 0
    local tagRlFv = 0
    if tagRl ~= nil then
        campRlState = tagRl.curState
        tagRlFv = tagRl.friendlyVal
    end
    local isFromPlayerCamp = dipInfo.fromCamp:IsPlayerOwnedCamp()
    local isToPlayerCamp = dipInfo.execCamp:IsPlayerOwnedCamp()
    local fromCampName = dipInfo.fromCamp:GetCampName()
    local toCampName = dipInfo.execCamp:GetCampName()
    local msgInfo
    local giftMoney = 0
    if not IsEmptyOrNilStr(dipInfo.argsVal) then
        giftMoney = tonumber(dipInfo.argsVal)
    end

    local aiLevelRatio = 1.0
    if dipInfo.fromCamp:IsPlayerOwnedCamp() then
        aiLevelRatio = (0.4 + CurGameWorld:GetAILevelRatio() * 0.3)
    end

    local fromResOwner = dipInfo.fromCamp:GetLeader()
    local execResOwner = dipInfo.execCamp:GetLeader()
    local changeFv = 0
    if dipInfo.dipType == DipEventGoodwill then
        --2：执行亲善
        if dipResult then
            --changeFv = GetRandomInt(2, 5) + math.floor(8 * dipInfo.resultRatio);
            if tagRlFv >=0 then
                changeFv = math.floor(giftMoney /((tagRlFv/10 + 1) * 200.0 * aiLevelRatio))
            else
                changeFv = math.floor(giftMoney /((-tagRlFv/10 + 1) * 200.0 * aiLevelRatio))
            end
            if execResOwner ~= nil then
                execResOwner:ChangeResourceNum(RES_ID_MONEY, giftMoney, false)
            end
            if isFromPlayerCamp then
                msgInfo = StringFormat(GetGameString("dip_goodwill_res_ok"), toCampName)
                msgInfo_title = StringFormat(GetGameString("dip_goodwill_res_ok_title"), toCampName)
                ShowGameMsg(msgInfo, 0)
                sendcamp_id = dipInfo.execCamp.CampID
                SendDipInteractiveReq(dipInfo, msgInfo_title, msgInfo, sendcamp_id)
            end
            SetCampRl(dipInfo.fromCamp.CampID, dipInfo.execCamp.CampID, -1, 1, changeFv, true)
        else
            if isFromPlayerCamp then
                msgInfo = StringFormat(GetGameString("dip_goodwill_res_fail"), toCampName)
                msgInfo_title = StringFormat(GetGameString("dip_goodwill_res_fail_title"), toCampName)
                ShowGameMsg(msgInfo, 1)
                sendcamp_id = dipInfo.execCamp.CampID
                SendDipInteractiveReq(dipInfo, msgInfo_title, msgInfo, sendcamp_id)
            end
            if fromResOwner ~= nil then
                --返还礼物资源
                fromResOwner:ChangeResourceNum(RES_ID_MONEY, giftMoney, false)
            end
        end
    elseif dipInfo.dipType == DipEventDeclareWar then
        if campRlState == 1 then
            return
        end
        --3：执行宣战
        if isToPlayerCamp then
            msgInfo = StringFormat(GetGameString("dip_declarewar_res0"), fromCampName)
            ShowGameMsg(msgInfo, 1)
            --SendDipInteractiveMsg(dipInfo, msgInfo)
        else
            msgInfo = StringFormat(GetGameString("dip_declarewar_res1"), fromCampName, toCampName)
            ShowGameMsg(msgInfo, 0)
        end
        local tagFv = tagRlFv
        if tagFv > -30 then
            tagFv = -30
        end
        SetCampRl(dipInfo.fromCamp.CampID, dipInfo.execCamp.CampID, 1, 2, tagFv, true)

        --宣战后提升目标势力所有敌对势力好感度
        local allCamps = GameCoreHelper.GetAllGameCamps()
        for i=0,allCamps.Count-1 do
            local c = allCamps[i]
            if (c.CampID == dipInfo.execCamp.CampID) then --当前势力
            elseif (not c:EnableAutoChangeDip()) then --过滤一些不受外交影响的阵营
            else
                local rl = GameCoreHelper.GetCampRelation(c.CampID, dipInfo.execCamp.CampID);
                if rl ~= nil then
                    if (rl.curState == 1) then
                        local friendlyVal = rl.friendlyVal    --当前的友好度
                        local changeValue = Clamp(math.floor(-friendlyVal * GetRandomNum(0.5, 0.75)), 0, 30)
                        if changeValue ~= 0 then
                            SetCampRl(dipInfo.fromCamp.CampID, c.CampID, -1, 1, changeValue, true)
                        end
                    end
                end
            end
        end
    elseif dipInfo.dipType == DipEventAlly then
        if campRlState ~= 0 then
            return
        end
        --4：执行结盟
        if dipResult  then
            if isFromPlayerCamp then
                msgInfo = StringFormat(GetGameString("dip_ally_res_ok"), toCampName)
                msgInfo_title = StringFormat(GetGameString("dip_ally_res_ok_title"), toCampName)
                ShowGameMsg(msgInfo, 0)
                sendcamp_id = dipInfo.execCamp.CampID
                SendDipInteractiveReq(dipInfo, msgInfo_title, msgInfo, sendcamp_id)
            end
            if execResOwner ~= nil then
                execResOwner:ChangeResourceNum(RES_ID_MONEY, giftMoney, false)
            end
            local tagFv = tagRlFv
            local opFvType = 1
            if tagFv < 30 then
                opFvType = 2
                tagFv = 30
            else
                tagFv = GetRandomInt(5, 11) + math.floor(10 * dipInfo.resultRatio)
            end
            SetCampRl(dipInfo.fromCamp.CampID, dipInfo.execCamp.CampID, 2, opFvType, tagFv, true)
            --结盟成功应该降低该势力所有敌对势力的好感度
            local allCamps = GameCoreHelper.GetAllGameCamps()
            for i=0,allCamps.Count-1 do
                local c = allCamps[i]
                if (c.CampID == dipInfo.execCamp.CampID) then --当前势力
                elseif (not c:EnableAutoChangeDip()) then --过滤一些不受外交影响的阵营
                else
                    local rl = GameCoreHelper.GetCampRelation(c.CampID, dipInfo.execCamp.CampID);
                    if rl ~= nil then
                        if (rl.curState == 1) then
                            local friendlyVal = rl.friendlyVal    --当前的友好度
                            local changeValue = -Clamp(math.floor(-friendlyVal * GetRandomNum(0.5, 0.75)), 0, 30)
                            if changeValue ~= 0 then
                                SetCampRl(dipInfo.fromCamp.CampID, c.CampID, -1, 1, changeValue, true)
                            end
                        end
                    end
                end
            end
        else
            if isFromPlayerCamp then
                msgInfo = StringFormat(GetGameString("dip_ally_res_fail"), toCampName)
                msgInfo_title = StringFormat(GetGameString("dip_ally_res_fail_title"), toCampName)
                ShowGameMsg(msgInfo, 1)
                sendcamp_id = dipInfo.execCamp.CampID
                SendDipInteractiveReq(dipInfo, msgInfo_title, msgInfo, sendcamp_id)
            end
            if fromResOwner ~= nil then
                --返还礼物资源
                fromResOwner:ChangeResourceNum(RES_ID_MONEY, giftMoney, false)
            end
        end
    elseif dipInfo.dipType == DipEventBreakAlly then
        if campRlState ~= 2 then
            return
        end
        --5：解除盟约
        if isToPlayerCamp then
            msgInfo = StringFormat(GetGameString("dip_abt_ally_res0"), fromCampName)
            ShowGameMsg(msgInfo, 1)
            --SendDipInteractiveMsg(dipInfo, msgInfo)
        else
            msgInfo = StringFormat(GetGameString("dip_abt_ally_res1"), fromCampName, toCampName)
            ShowGameMsg(msgInfo, 0)
        end
        local tagFv = tagRlFv
        if tagFv > 20 then
            tagFv = 20
        end
        SetCampRl(dipInfo.fromCamp.CampID, dipInfo.execCamp.CampID, 0, 2, tagFv, true)
    elseif dipInfo.dipType == DipEventTruce then
        if campRlState ~= 1 then
            return
        end
        --6：执行停战
        if dipResult then
            if isFromPlayerCamp then
                msgInfo = StringFormat(GetGameString("dip_truce_res_ok"), toCampName)
                msgInfo_title = StringFormat(GetGameString("dip_truce_res_ok_title"), toCampName)
                ShowGameMsg(msgInfo, 0)
                sendcamp_id = dipInfo.execCamp.CampID
                SendDipInteractiveReq(dipInfo, msgInfo_title, msgInfo, sendcamp_id)
            end
            local tagFv = tagRlFv
            if tagFv < 0 then
                tagFv = 0
            end
            SetCampRl(dipInfo.fromCamp.CampID, dipInfo.execCamp.CampID, 0, 2, tagFv, true)
            if execResOwner ~= nil then
                execResOwner:ChangeResourceNum(RES_ID_MONEY, giftMoney, false)
            end
        else
            if isFromPlayerCamp then
                msgInfo = StringFormat(GetGameString("dip_truce_res_fail"), toCampName)
                msgInfo_title = StringFormat(GetGameString("dip_truce_res_fail_title"), toCampName)
                ShowGameMsg(msgInfo, 1)
                sendcamp_id = dipInfo.execCamp.CampID
                SendDipInteractiveReq(dipInfo, msgInfo_title, msgInfo, sendcamp_id)
            end
            if fromResOwner ~= nil then
                --返还礼物资源
                fromResOwner:ChangeResourceNum(RES_ID_MONEY, giftMoney, false)
            end
        end
    end

    --脚本事件接口：玩家发起请求的外交活动返回结果
    if isFromPlayerCamp then
        local curRtVals = GameCoreHelper.CreateEmptyRuntimeArgVal()
        curRtVals.CurTagCamp = dipInfo.execCamp;
        curRtVals.CurDipInfo = dipInfo;
        curRtVals.argIntVal1 = giftMoney;
        local dipTypeStr = tostring(dipInfo.dipType)
        if dipResult then
            GameCoreHelper.CheckGameTrigger("dip_ret_success", dipTypeStr, dipInfo.execCamp.CampID, curRtVals)
        else
            GameCoreHelper.CheckGameTrigger("dip_ret_fail", dipTypeStr, dipInfo.execCamp.CampID, curRtVals)
        end
    end

    --发送UI刷新消息
    GameCoreHelper.SendSceneUIMessage("update_dip_info", nil)

    dipInfo.isDecided = true;
end

--设置或改变阵营之间的外交好感度及外交关系接口
--rlState：新的外交关系状态 -1:保持原状态 0:中立 1：交战 2：结盟 3：己方
--fvOpMode：好感度操作方式 0:不改变 1：增加 2：设置到目标值
function SetCampRl(campID1, campID2, rlState, fvOpMode, fvOpVal, isNotify)
    if IsEmptyOrNilStr(campID1) or IsEmptyOrNilStr(campID2) then
        return
    end
    local campA = GameCoreHelper.GetGameCamp(campID1)
    local campB = GameCoreHelper.GetGameCamp(campID2)
    if campA == nil or campB == nil then
        return
    end
    local oldRlState = 0
    local oldFv = 0
    local tagRlInfo = GameCoreHelper.GetCampRelation(campID1, campID2)
    if tagRlInfo ~= nil then
        oldRlState = tagRlInfo.curState
        oldFv = tagRlInfo.friendlyVal
    end
    local isRlStateChanged = false
    local isFvChanged = false
    if rlState ~= -1 and rlState ~= oldRlState then
        isRlStateChanged = true
    end
    local newFv = oldFv
    if fvOpMode == 1 then
        newFv = oldFv + fvOpVal
    elseif fvOpMode == 2 then
        newFv = fvOpVal
    end
    newFv = Clamp(newFv, RelationshipMinVal, RelationshipMaxVal)
    if newFv ~= oldFv then
        isFvChanged = true
    end

    if isRlStateChanged or isFvChanged then
        if not isRlStateChanged and isFvChanged then
            --判定是否自动宣战
            if oldFv >= CampRelationAutoDeclareWarLine and newFv < CampRelationAutoDeclareWarLine then
                rlState = 1
                isRlStateChanged = true
            end
        end
        CS.GameTools.DoSetCampRlVal(campID1, campID2, rlState, isFvChanged, newFv)

        if isNotify then
            local playerRole = GameCoreHelper.GetPlayerRole()
            local playerOpTagCamp = nil
            local playerCamp = nil
            if playerRole.CurRoleCampID == campID1 then
                playerCamp = campA
                playerOpTagCamp = campB
            elseif playerRole.CurRoleCampID == campID2 then
                playerCamp = campB
                playerOpTagCamp = campA
            end
            if playerCamp ~= nil and playerOpTagCamp ~= nil then
                local msgT = 0
                if isFvChanged and playerCamp.Leader == playerRole.roleID then
                    --只有玩家是领主时订阅阵营关系改变消息
                    local deltaVal = newFv - oldFv
                    local campName = playerOpTagCamp:GetCampName()
                    if (deltaVal > 0) then
                        msgInfo = StringFormat(GetGameString("player_campfv_add"), campName, deltaVal, newFv)
                    else
                        msgT = 1
                        msgInfo = StringFormat(GetGameString("player_campfv_minus"), campName, -deltaVal, newFv)
                    end
                    ShowGameMsg(msgInfo, 0)
                end
                if isRlStateChanged then
                    if rlState == 1 then
                        GameCoreHelper.CheckQuestStateCampEnemy(playerOpTagCamp.CampID)
                        msgT = 1
                    end
                    local campRlName = CS.GameTools.GetCampRlStateName(rlState);
                    local msgInfo = StringFormat(GetGameString("camp_rl_state_chg"),
                                        playerOpTagCamp:GetCampName(), playerCamp:GetCampName(), campRlName);
                    ShowGameMsg(msgInfo, msgT)
                end
            end
        end
    end
end


--获取外交友善行为所需的最少金钱数
function GetDipGoodwillMoneyMin(thisCamp, tagCamp)
    --return math.floor(500 + CurGameWorld.curGameTime * 10)
    local tagRl = GameCoreHelper.GetCampRelation(thisCamp.CampID, tagCamp.CampID)
    local camprelation = 0
    if tagRl ~= nil then
        camprelation = tagRl.friendlyVal
    end
    local aiLevelRatio = (0.4 + CurGameWorld:GetAILevelRatio() * 0.3)

    if camprelation ~= nil then
        if camprelation >= 0 then
            return math.floor((camprelation + 1) * 100 * aiLevelRatio)
        else
            return math.floor((-camprelation) * 100 * aiLevelRatio)
        end
    end
end

--获取外交结盟所需的最少金钱数
function GetDipAllyMoneyMin(thisCamp, tagCamp)
    --return math.floor(1200 + CurGameWorld.curGameTime * 20) 旧公式
    local tagRl = GameCoreHelper.GetCampRelation(thisCamp.CampID, tagCamp.CampID)
    local camprelation = 0
    if tagRl ~= nil then
        camprelation = tagRl.friendlyVal
    end
    local myPower = thisCamp.CurPower + 1.0
    local aiLevelRatio = (0.4 + CurGameWorld:GetAILevelRatio() * 0.3)
    local power_multi = math.floor(Clamp(tagCamp.CurPower/myPower, 0.3, 3))
    local rl_multi = math.ceil((camprelation -30)/20)
    return math.floor(Clamp((power_multi * 3500 * aiLevelRatio / rl_multi), 3500, 30000))
end

--获取外交停战所需的最少金钱数
function GetDipTruceMoneyMin(thisCamp, tagCamp)
    --return math.floor(tagCamp.CurPower * 5.0) 旧公式
    local tagRl = GameCoreHelper.GetCampRelation(thisCamp.CampID, tagCamp.CampID)
    local camprelation = 0
    if tagRl ~= nil then
        camprelation = tagRl.friendlyVal
    end
    local myPower = thisCamp.CurPower + 1.0
    local aiLevelRatio = (0.4 + CurGameWorld:GetAILevelRatio() * 0.3)
    local rl_multi = math.ceil(-camprelation/30)
    local power_multi = math.floor(Clamp(tagCamp.CurPower/myPower, 0.3, 3))
    return math.floor(Clamp((power_multi * 5000 * rl_multi * aiLevelRatio / 2), 5000, 30000))
end

--给玩家发送外交事件的通知短信
function SendDipInteractiveMsg(dipInfo, msgInfo)
    local title = msgInfo
    local content = msgInfo
    local argVal = "ask:" .. GetGameString("inter_msg_delete_btn") .. "=通用删除当前交互消息"
    CurGameWorld:AddInteractiveMessage("msg", title, content, argVal, 7, 0, "", nil)
end

function SendDipInteractiveReq(dipInfo, msgInfo_title, msgInfo, campid)
    local title = msgInfo_title
    local content = msgInfo
    local sendcamp = campid
    local argVal = "ask:" .. GetGameString("inter_msg_delete_btn") .. "=通用删除当前交互消息"
    CurGameWorld:AddInteractiveMessage("request", title, content, argVal, 7, 3, sendcamp, nil)
end

-------------------------------------------经济系统相关-------------------------------------------------

---* 农民派出时逻辑
---@param fromPlace HanFramework.GamePlaceRtData
---@param aimPlace HanFramework.GamePlaceRtData
---@param caravanTeam TeamInMap
function OnSendFarmer(fromPlace, aimPlace, caravanTeam)
    local money = math.ceil(GetFarmerStartMoney())
    ---* 购买特产
    local buyGoods = fromPlace:CaravanTradeLocalProduct(money, FarmerBuyProductMaxCount);
    caravanTeam:AddInventoryItems(buyGoods)
    -- print("来自 " .. fromPlace:GetPlaceName() .. " 的农民出发了，他们初始金钱有：" .. money ..
    --     " ，他们的商品有：" .. CS.GameUtils.GetItemListStr(caravanTeam.inventoryItemList))
end

---* 商队派出时逻辑
---@param fromPlace HanFramework.GamePlaceRtData
---@param aimPlace HanFramework.GamePlaceRtData
---@param caravanTeam TeamInMap
function OnSendCaravan(fromPlace, aimPlace, caravanTeam)
    ---* 计算起始资金
    local money = GetCaravanStartMoney()
    local extra_money = fromPlace:GetPlaceStat("ps_产出金钱") / 2
    local final_money = math.ceil(money + extra_money);
    ---* 购买特产
    local buyGoods = fromPlace:CaravanTradeLocalProduct(final_money, CaravanBuyProductMaxCount);
    caravanTeam:AddInventoryItems(buyGoods)
    -- print("来自 " .. fromPlace:GetPlaceName() .. " 的商队出发了，他们初始金钱有：" .. final_money ..
    --     " ，他们的商品有：" .. CS.GameUtils.GetItemListStr(caravanTeam.inventoryItemList))
end

---* 商队交易时逻辑
---@param curPlace HanFramework.GamePlaceRtData
---@param caravanTeam TeamInMap
function OnCaravanDoTrade(curPlace, caravanTeam)
    local money = 0
    ---* 卖出身上货物
    for k, v in pairs(caravanTeam.inventoryItemList) do
        ---@type HanFramework.GameItemData
        local item = v
        if item.BindLocalProduct ~= nil then
            --- 特产计算特产价格系数
            local multiple = CS.MerchantLogic.GetLocalProductionMultiple(item.BindLocalProduct, curPlace) + 0.3
            money = money + item.unitPrice * item.itemCount * multiple
        elseif item.itemID == RES_ID_MONEY then
            money = money + item.itemCount
            -- print("剩余金钱：" .. item.itemCount)
        else
            --- 非特产按默认价格 * 1.3
            money = math.ceil(money + item.unitPrice * item.itemCount * 1.3)
        end
    end
    caravanTeam:ClearInventoryItems()
    ---* 重新买入当地特产
    local buyGoods = curPlace:CaravanTradeLocalProduct(money, CaravanBuyProductMaxCount);
    caravanTeam:AddInventoryItems(buyGoods)
    -- print("一支商队在 " .. curPlace:GetPlaceName() .. " 卖出特产获得了：" .. money ..
    --     " ，他们新买入的商品有：" .. CS.GameUtils.GetItemListStr(caravanTeam.inventoryItemList))
end

---* 农民基础金钱
function GetFarmerStartMoney()
    -- 按游戏月数进行计算
    local curMonth = math.ceil(CurGameWorld.curGameTime / 30)
    local level = Clamp(curMonth, 1, #CaravanStartMoney)
    local startMoney = FarmerStartMoney[level] * GetRandomNum(0.8, 1.2)
    return startMoney
end

---* 商队基础金钱
function GetCaravanStartMoney()
    -- 按游戏月数进行计算
    local curMonth = math.ceil(CurGameWorld.curGameTime / 30)
    local level = Clamp(curMonth, 1, #CaravanStartMoney)
    local startMoney = CaravanStartMoney[level] * GetRandomNum(0.8, 1.2)
    return startMoney
end

--地点修理调用
function CallPlaceRepairUI(contextArgVal)
    local curRepairNum = CurGameWorld:RepairableEquipItemsCount();
	if curRepairNum <= 0 then
        CS.GlobalUI.Instance:ShowToastInfo(GetGameString("RepairWin_NoRepairableItems"), 3);
		return;
	end

	CS.GUIHelper.ShowRepairEquipsWindow(nil);
end

-------------------------------------------自定义方法-------------------------------------------------

--队伍内卡牌随机损失耐久度 参数格式：最大影响卡牌数量,最小耐久损失,最大耐久损失
function TeamCardsLossDurability(contextArgVal, _args)
    local maxCount = 1;
    local lossValMin = 1;
    local lossValMax = 1;
    local playerTeam = GameCoreHelper.GetPlayerTeam();
    if not IsEmptyOrNil(_args) then
        local argLines = SplitStr(_args, ",");
        if #argLines >= 1 then
            maxCount = tonumber(argLines[1]);
        end
        if #argLines >= 2 then
            lossValMin = tonumber(argLines[2]);
        end
        if #argLines >= 3 then
            lossValMax = tonumber(argLines[3]);
        end
        if lossValMax < lossValMin then
            lossValMax = lossValMin;
        end
    end
    local rndPool = GameCoreHelper.GetEmptyCardsItemList();
    rndPool:AddRange(playerTeam.soldierCardsInTeam);
    local tagCard;
    for index=0, maxCount - 1 do
        if rndPool.Count <= 0 then
            break;
        end
        tagCard = GetRandomListItem(rndPool, rndPool.Count)
        if tagCard ~= nil then
            local reduceNum = GameCoreHelper.GetRandomInt(lossValMin, lossValMax + 1);
            tagCard:ReduceDurability(reduceNum);
            rndPool:Remove(tagCard);
        end
    end
end

--升级队伍中某个拥有指定技能的队友的技能等级
function UpgradeSkillInTeam(contextArgVal, _args)
    local curUsingItem = nil;
	if _args ~= nil then
		curUsingItem = _args.CurTagItem;
	end
    if not IsEmptyOrNil(_args) then
        local argLines = SplitStr(_args, ",");
        local skillID;
        local addLevel = 1;
        if #argLines >= 1 then
            skillID = argLines[1];
        end
        if #argLines >= 2 then
            addLevel = tonumber(argLines[2]);
        end
        local isDefRole = false;
        local defRoleID = nil;
        if #argLines >= 3 then
            isDefRole = true;
            defRoleID = argLines[3];
        end
        local tagRoleInfo;
        local curSkillLevel;
        local tagSkillInfo = GameCoreHelper.GetSkillInfo(skillID);
        if tagSkillInfo == nil then
            return;
        end
        local skillMaxLevel = tagSkillInfo.MaxLevel;
        if isDefRole then
            DoUpgrageTagRoleSkill(defRoleID, skillID, skillMaxLevel, curUsingItem, tagSkillInfo, addLevel);
        else
            local playerTeam = GameCoreHelper.GetPlayerTeam();
            local curRoleList = playerTeam.rolesInTeam;
            local enableRoles = GameCoreHelper.GetEmptyRoleList();
            for index=0,curRoleList.Count-1 do
                tagRoleInfo = curRoleList[index];
                curSkillLevel = tagRoleInfo:GetLearnedSkillLevel(skillID);
                if curSkillLevel > 0 and curSkillLevel < skillMaxLevel then
                    enableRoles:Add(tagRoleInfo);
                end
            end
            if enableRoles.Count > 0 then
                CS.GUIHelper.ShowSelectRoleFromListUI(GetGameString("lua_script_str_105"), enableRoles, function(_ret, _roleID)
                    if _ret == 1 then
                        DoUpgrageTagRoleSkill(_roleID, skillID, skillMaxLevel, curUsingItem, tagSkillInfo, addLevel);
                    end
                end)
            else
                local sInfo =  GetGameString("lua_script_str_107");
                ShowToastInfo(sInfo, 3);
            end
        end
    end
end

function DoUpgrageTagRoleSkill(_roleID, skillID, skillMaxLevel, curUsingItem, tagSkillInfo, addLevel)
    local playerTeam = GameCoreHelper.GetPlayerTeam();
    local seledRole = GameCoreHelper.GetRole(_roleID);
    if seledRole ~= nil then
        curSkillLevel = seledRole:GetLearnedSkillLevel(skillID);
    end
    local tagLevel = curSkillLevel + addLevel;
    if tagLevel > skillMaxLevel then
        tagLevel = skillMaxLevel;
    end
    seledRole:LearnSkill(skillID, tagLevel, false, false, true);
    if curUsingItem ~= nil then
        --使用结束后将当前的使用道具数量减一
        GameCoreHelper.RemovePlayerSpecificItem(curUsingItem, 1, false);
    end
    local sInfo = StringFormat(GetGameString("lua_script_str_106"),
            seledRole:GetRoleName(), tagSkillInfo.skill_name, tagLevel);
    ShowToastInfo(sInfo, 3);

    playerTeam.isTeamUpdated = true;
end

--------------------------------------DLC1Change--------------------------------------
VAL_ID_EXTRA_STATU = "额外属性加成"
---* 获取角色指定的额外属性加成值，值存储在指定的字符串中，默认不指定则默认存储在[%str_val:额外属性加成%]中
---* 指令：RUN_SCRIPT_FUNC*GameLogics#GetExtraStatuValueToStr#角色ID,属性KEY,存储值的字符串ID
---* 示例：RUN_SCRIPT_FUNC*GameLogics#GetExtraStatuValueToStr#主角,team_重伤率
---@param _contextArgVal RuntimeArgVals
---@param _StrArgs string
function GetExtraStatuValueToStr(_contextArgVal, _StrArgs)
    local curInfoList = SplitStr(_StrArgs, ",")

    local roleID = curInfoList[1]
    local statuKey = curInfoList[2]

    if _contextArgVal then
        roleID = _contextArgVal.CurTagRoleID
    end
    if IsEmptyOrNilStr(roleID) then
        roleID = curInfoList[1]
    end

    local tagRole = GameCoreHelper.GetRole(roleID)
    if not tagRole then
        DebugError("错误：不存在的角色,id=" .. roleID)
        return
    end
    local statuValue = tagRole.extraStatu:getVal(statuKey)

    if curInfoList[3] then
        GameCoreHelper.SetStrVar(curInfoList[3], statuValue)
    else
        GameCoreHelper.SetStrVar(VAL_ID_EXTRA_STATU, statuValue)
    end
end

VAL_ID_SAVE_DISTRIBSP_SP = "加点技能保存列表_"
VAL_ID_SAVE_SKILLPAGE = "技能页保存列表_"
---* 保存角色的加点技能列表，值存储在指定的字符串中，默认不指定则默认存储在[%str_val:加点技能保存列表_角色ID%]中
---* 指令：RUN_SCRIPT_FUNC*GameLogics#SaveDistributeSkillList#角色ID,存储加点技能的字符串ID,存储技能页的字符串ID
---* 示例：RUN_SCRIPT_FUNC*GameLogics#SaveDistributeSkillList#曲玉
---@param _contextArgVal RuntimeArgVals
---@param _StrArgs string
function SaveDistributeSkillList(_contextArgVal, _StrArgs)
    local curInfoList = SplitStr(_StrArgs, ",")

    local roleID = ""
    if _contextArgVal then
        roleID = _contextArgVal.CurTagRoleID
    end
    if IsEmptyOrNilStr(roleID) then
        roleID = curInfoList[1]
    end

    local tagRole = GameCoreHelper.GetRole(roleID)
    if tagRole == nil then
        DebugError("错误：不存在的角色,id=" .. roleID)
        return
    end

    local skillInfo = ""
    local allDistribSpList = CS.GameTools.GetSpListBySDic(tagRole.distributeSpList);
    for index = 0, allDistribSpList.Count-1 do
        local curSp = allDistribSpList[index]
        skillInfo = skillInfo .. curSp.skillID .. "," .. curSp.skillLevel .. "|"
    end

    if curInfoList[2] then
        GameCoreHelper.SetStrVar(curInfoList[2], skillInfo)
    else
        GameCoreHelper.SetStrVar(VAL_ID_SAVE_DISTRIBSP_SP .. roleID, skillInfo)
    end

    local skillPageInfo = ""
    local allPagesList = tagRole.skillPagesList
    for index = 0, allPagesList.Count-1 do
        local curPageID = allPagesList[index]
        skillPageInfo = skillPageInfo .. curPageID .. "|"
    end

    if curInfoList[3] then
        GameCoreHelper.SetStrVar(curInfoList[3], skillPageInfo)
    else
        GameCoreHelper.SetStrVar(VAL_ID_SAVE_SKILLPAGE .. roleID, skillPageInfo)
    end

end

---* 尝试按保存的加点技能列表加点
---* 指令：RUN_SCRIPT_FUNC*GameLogics#LoadDistributeSkillList#角色ID,是否洗点,读取加点技能的字符串id,读取技能页的字符串id
---* 说明：是否洗点-为1时将先进行洗点后再加点；读取的字符串id为空时，默认读取[%str_val:加点技能保存列表_角色ID%]中的数据
---* 示例：RUN_SCRIPT_FUNC*GameLogics#LoadDistributeSkillList#曲玉,0
---@param _contextArgVal RuntimeArgVals
---@param _StrArgs string
function LoadDistributeSkillList(_contextArgVal, _StrArgs)
    local curInfoList = SplitStr(_StrArgs, ",")

    local isResetRoleSp = tonumber(curInfoList[2])
    local roleID
    if _contextArgVal then
        roleID = _contextArgVal.CurTagRoleID
    end
    if IsEmptyOrNilStr(roleID) then
        roleID = curInfoList[1]
    end

    local tagRole = GameCoreHelper.GetRole(roleID)
    if not tagRole then
        DebugError("错误：不存在的角色,id=" .. roleID)
        return
    end

    if isResetRoleSp == 1 then
        tagRole:ResetRoleSp()
    end

    local skillInfo = ""
    if curInfoList[3] then
        skillInfo = GameCoreHelper.GetStrVar(curInfoList[3])
    else
        skillInfo =  GameCoreHelper.GetStrVar(VAL_ID_SAVE_DISTRIBSP_SP .. roleID)
    end

    local skillStrList = SplitStr(skillInfo, "|")

    for i = 1, tagRole.unusedSp do
        local curInfo = skillStrList[i]
        if curInfo then
            local curList = SplitStr(curInfo, ",")
            local tagSkillID = curList[1]
            local tagLevel = tonumber(curList[2]) or 1
            local tagSp = CS.SkillPointData(tagSkillID, 1)
            if not IsEmptyOrNilStr(tagSp.skillID) then
                local useSp = tagLevel - tagRole:GetLearnedSkillLevel(tagSkillID)
                if useSp > 0 then
                    tagRole:LearnSkill(tagSkillID, tagLevel, true, false, true, true)
                    tagRole:ChangeUnusedSp(-useSp)
                end
            end
        else
            break
        end
    end

    local skillPageInfo = ""
    if curInfoList[4] then
        skillPageInfo = GameCoreHelper.GetStrVar(curInfoList[4])
    else
        skillPageInfo =  GameCoreHelper.GetStrVar(VAL_ID_SAVE_SKILLPAGE .. roleID)
    end

    local skillPageStrList = SplitStr(skillPageInfo, "|")

    for i = 1, #skillPageStrList do
        local curInfo = skillPageStrList[i]
        if curInfo then
            local curList = SplitStr(curInfo, ",")
            local tagPageID = curList[1]
            local tagPage = GameCoreHelper.GetSkillPageInfo(tagPageID)
            if tagPage then
                tagRole:AddSkillPage(tagPageID, false)
            end
        end
    end
end
